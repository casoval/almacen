# Generated by Django 5.2.8 on 2025-12-13 01:30

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('stock_cache', '0002_populate_initial_stock'),
    ]

    operations = [
        # Función trigger para actualizar stock cache
        migrations.RunSQL(
            """
            CREATE OR REPLACE FUNCTION update_stock_cache()
            RETURNS TRIGGER AS $$
            DECLARE
                mov RECORD;
                delta_bueno DECIMAL(12,2) := 0;
                delta_danado DECIMAL(12,2) := 0;
                target_almacen_id INTEGER;
            BEGIN
                -- Obtener el movimiento
                SELECT * INTO mov FROM almacenes_movimientoalmacen WHERE id = COALESCE(NEW.movimiento_id, OLD.movimiento_id);

                -- Determinar el almacén objetivo y los deltas según el tipo de operación
                CASE
                    WHEN TG_OP = 'INSERT' THEN
                        CASE mov.tipo
                            WHEN 'ENTRADA' THEN
                                target_almacen_id := mov.almacen_destino_id;
                                delta_bueno := NEW.cantidad;
                                delta_danado := NEW.cantidad_danada;
                            WHEN 'SALIDA' THEN
                                target_almacen_id := mov.almacen_origen_id;
                                delta_bueno := -NEW.cantidad;
                                delta_danado := -NEW.cantidad_danada;
                            WHEN 'TRASLADO' THEN
                                -- Para traslados, actualizar origen y destino
                                -- Primero el origen (resta)
                                INSERT INTO stock_cache_stockcache (producto_id, almacen_id, stock_bueno, stock_danado, stock_total, ultima_actualizacion)
                                VALUES (NEW.producto_id, mov.almacen_origen_id, -NEW.cantidad, -NEW.cantidad_danada, -(NEW.cantidad + NEW.cantidad_danada), NOW())
                                ON CONFLICT (producto_id, almacen_id)
                                DO UPDATE SET
                                    stock_bueno = stock_cache_stockcache.stock_bueno - NEW.cantidad,
                                    stock_danado = stock_cache_stockcache.stock_danado - NEW.cantidad_danada,
                                    stock_total = stock_cache_stockcache.stock_total - (NEW.cantidad + NEW.cantidad_danada),
                                    ultima_actualizacion = NOW();

                                -- Luego el destino (suma)
                                INSERT INTO stock_cache_stockcache (producto_id, almacen_id, stock_bueno, stock_danado, stock_total, ultima_actualizacion)
                                VALUES (NEW.producto_id, mov.almacen_destino_id, NEW.cantidad, NEW.cantidad_danada, NEW.cantidad + NEW.cantidad_danada, NOW())
                                ON CONFLICT (producto_id, almacen_id)
                                DO UPDATE SET
                                    stock_bueno = stock_cache_stockcache.stock_bueno + NEW.cantidad,
                                    stock_danado = stock_cache_stockcache.stock_danado + NEW.cantidad_danada,
                                    stock_total = stock_cache_stockcache.stock_total + (NEW.cantidad + NEW.cantidad_danada),
                                    ultima_actualizacion = NOW();

                                RETURN NEW;
                        END CASE;

                    WHEN TG_OP = 'UPDATE' THEN
                        -- Para updates, primero revertir el old y luego aplicar el new
                        CASE mov.tipo
                            WHEN 'ENTRADA' THEN
                                target_almacen_id := mov.almacen_destino_id;
                                delta_bueno := NEW.cantidad - OLD.cantidad;
                                delta_danado := NEW.cantidad_danada - OLD.cantidad_danada;
                            WHEN 'SALIDA' THEN
                                target_almacen_id := mov.almacen_origen_id;
                                delta_bueno := -(NEW.cantidad - OLD.cantidad);
                                delta_danado := -(NEW.cantidad_danada - OLD.cantidad_danada);
                            WHEN 'TRASLADO' THEN
                                -- Para traslados, actualizar origen y destino
                                -- Primero revertir old y aplicar new para origen
                                UPDATE stock_cache_stockcache SET
                                    stock_bueno = stock_bueno - OLD.cantidad + NEW.cantidad,
                                    stock_danado = stock_danado - OLD.cantidad_danada + NEW.cantidad_danada,
                                    stock_total = stock_total - (OLD.cantidad + OLD.cantidad_danada) + (NEW.cantidad + NEW.cantidad_danada),
                                    ultima_actualizacion = NOW()
                                WHERE producto_id = NEW.producto_id AND almacen_id = mov.almacen_origen_id;

                                -- Luego para destino
                                UPDATE stock_cache_stockcache SET
                                    stock_bueno = stock_bueno + OLD.cantidad - NEW.cantidad,
                                    stock_danado = stock_danado + OLD.cantidad_danada - NEW.cantidad_danada,
                                    stock_total = stock_total + (OLD.cantidad + OLD.cantidad_danada) - (NEW.cantidad + NEW.cantidad_danada),
                                    ultima_actualizacion = NOW()
                                WHERE producto_id = NEW.producto_id AND almacen_id = mov.almacen_destino_id;

                                RETURN NEW;
                        END CASE;

                    WHEN TG_OP = 'DELETE' THEN
                        CASE mov.tipo
                            WHEN 'ENTRADA' THEN
                                target_almacen_id := mov.almacen_destino_id;
                                delta_bueno := -OLD.cantidad;
                                delta_danado := -OLD.cantidad_danada;
                            WHEN 'SALIDA' THEN
                                target_almacen_id := mov.almacen_origen_id;
                                delta_bueno := OLD.cantidad;
                                delta_danado := OLD.cantidad_danada;
                            WHEN 'TRASLADO' THEN
                                -- Para traslados, revertir origen y destino
                                UPDATE stock_cache_stockcache SET
                                    stock_bueno = stock_bueno + OLD.cantidad,
                                    stock_danado = stock_danado + OLD.cantidad_danada,
                                    stock_total = stock_total + (OLD.cantidad + OLD.cantidad_danada),
                                    ultima_actualizacion = NOW()
                                WHERE producto_id = OLD.producto_id AND almacen_id = mov.almacen_origen_id;

                                UPDATE stock_cache_stockcache SET
                                    stock_bueno = stock_bueno - OLD.cantidad,
                                    stock_danado = stock_danado - OLD.cantidad_danada,
                                    stock_total = stock_total - (OLD.cantidad + OLD.cantidad_danada),
                                    ultima_actualizacion = NOW()
                                WHERE producto_id = OLD.producto_id AND almacen_id = mov.almacen_destino_id;

                                RETURN OLD;
                        END CASE;
                END CASE;

                -- Para ENTRADA y SALIDA (no traslados), actualizar el stock
                IF target_almacen_id IS NOT NULL THEN
                    INSERT INTO stock_cache_stockcache (producto_id, almacen_id, stock_bueno, stock_danado, stock_total, ultima_actualizacion)
                    VALUES (COALESCE(NEW.producto_id, OLD.producto_id), target_almacen_id, delta_bueno, delta_danado, delta_bueno + delta_danado, NOW())
                    ON CONFLICT (producto_id, almacen_id)
                    DO UPDATE SET
                        stock_bueno = stock_cache_stockcache.stock_bueno + delta_bueno,
                        stock_danado = stock_cache_stockcache.stock_danado + delta_danado,
                        stock_total = stock_cache_stockcache.stock_total + (delta_bueno + delta_danado),
                        ultima_actualizacion = NOW();
                END IF;

                RETURN COALESCE(NEW, OLD);
            END;
            $$ LANGUAGE plpgsql;
            """,
            reverse_sql="DROP FUNCTION IF EXISTS update_stock_cache();"
        ),

        # Trigger para INSERT
        migrations.RunSQL(
            """
            CREATE TRIGGER stock_cache_insert_trigger
                AFTER INSERT ON almacenes_detallemovimientoalmacen
                FOR EACH ROW EXECUTE FUNCTION update_stock_cache();
            """,
            reverse_sql="DROP TRIGGER IF EXISTS stock_cache_insert_trigger ON almacenes_detallemovimientoalmacen;"
        ),

        # Trigger para UPDATE
        migrations.RunSQL(
            """
            CREATE TRIGGER stock_cache_update_trigger
                AFTER UPDATE ON almacenes_detallemovimientoalmacen
                FOR EACH ROW EXECUTE FUNCTION update_stock_cache();
            """,
            reverse_sql="DROP TRIGGER IF EXISTS stock_cache_update_trigger ON almacenes_detallemovimientoalmacen;"
        ),

        # Trigger para DELETE
        migrations.RunSQL(
            """
            CREATE TRIGGER stock_cache_delete_trigger
                AFTER DELETE ON almacenes_detallemovimientoalmacen
                FOR EACH ROW EXECUTE FUNCTION update_stock_cache();
            """,
            reverse_sql="DROP TRIGGER IF EXISTS stock_cache_delete_trigger ON almacenes_detallemovimientoalmacen;"
        ),
    ]
